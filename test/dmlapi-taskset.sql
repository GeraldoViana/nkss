------------------------------------------------------------------------------------------------------------------------
-- NKSS: PL/SQL Simple Scheduler
-- * This script tests DML API(CRUD) for table NKSS_TASKSET(Generated by NKSG Simple Generator);
-- * Some additional code were added/modified/removed after generation, as SEQUENCE, SYSTIMESTAMP, etc;
------------------------------------------------------------------------------------------------------------------------
-- @dmlapi-taskset.sql
------------------------------------------------------------------------------------------------------------------------
set echo off
spool dmlapi-taskset.log
prompt +-------------------------------------------------------------------------+
prompt | NKSS: PL/SQL Simple Scheduler                                           |
prompt |-------------------------------------------------------------------------|
prompt | (c) Copyright 2017 Geraldo Viana (r4vrya@gmail.com)                     |
prompt |                                                                         |
prompt | Licensed under the Apache License, Version 2.0 (the "License"):         |
prompt | you may not use this file except in compliance with the License.        |
prompt | You may obtain a copy of the License at                                 |
prompt |                                                                         |
prompt |     http://www.apache.org/licenses/LICENSE-2.0                          |
prompt |                                                                         |
prompt | Unless required by applicable law or agreed to in writing, software     |
prompt | distributed under the License is distributed on an "AS IS" BASIS,       |
prompt | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.|
prompt | See the License for the specific language governing permissions and     |
prompt | limitations under the License.                                          |
prompt |-------------------------------------------------------------------------|
prompt | SQL> @dmlapi-taskset.sql                                                |
prompt +-------------------------------------------------------------------------+
whenever sqlerror continue
whenever oserror  continue
set define off
set feedback on
set heading off
set linesize 120
set loboffset 1
set long 16777216
set longchunksize 8192
set pause off
set scan on
set serveroutput on size 1000000
set sqlblanklines on
set tab off
set termout on
set timing on
set trimspool on
set verify off
set wrap on

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_taskset_dml.insert_row()                                                                    |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: PL/SQL procedure successfully completed                                               |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lr_data    nkss_taskset_dml.RecData;
begin
  dbms_output.enable(buffer_size => 1e6);
  -- Not mandatory will be replaced by sequence value on insert
  lr_data.id := -51;                                                                              --001 number(16)
  -- Not mandatory will be replaced by systimestamp on insert/update
  lr_data.created := to_timestamp('2008-04-23 11:59:37.145265665', 'yyyy-mm-dd hh24:mi:ss.ff');   --002 timestamp
  -- Mandatory
  lr_data.label := 'Initial Label';                                                               --003 varchar2(150 byte)
  -- Not mandatory
  lr_data.payload := 'begin null; end;';                                                          --004 clob
  -- Cannot be assigned on insert. Will be nulled
  lr_data.errorstack := 'The API will wipe me off';                                               --005 varchar2(4000 byte)
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| Data before nkss_taskset_dml.insert_row() call                                                   |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('lr_data.id              = ' || to_char(lr_data.id));
  dbms_output.put_line('lr_data.created         = ' || to_char(lr_data.created, 'yyyy-mm-dd hh24:mi:ss.ff'));
  dbms_output.put_line('lr_data.label           = ' || lr_data.label);
  dbms_output.put_line('lr_data.payload(length) = ' || dbms_lob.getlength(lob_loc => lr_data.payload));
  dbms_output.put_line('lr_data.errorstack      = ' || lr_data.errorstack);
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| nkss_taskset_dml.insert_row() call                                                               |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  nkss_taskset_dml.insert_row(fr_data => lr_data);
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| Data after nkss_taskset_dml.insert_row() call                                                    |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('lr_data.id              = ' || to_char(lr_data.id));
  dbms_output.put_line('lr_data.created         = ' || to_char(lr_data.created, 'yyyy-mm-dd hh24:mi:ss.ff'));
  dbms_output.put_line('lr_data.label           = ' || lr_data.label);
  dbms_output.put_line('lr_data.payload(length) = ' || dbms_lob.getlength(lob_loc => lr_data.payload));
  dbms_output.put_line('lr_data.errorstack      = ' || lr_data.errorstack);
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  commit;
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_taskset_dml.select_row(fv_lock => true)   * main transaction                                |
prompt | nkss_taskset_dml.lock_row()                    * autonomous transaction                          |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: ORA-20888 rowid[%s] locked by another session                                         |
prompt | * after about 4 seconds                                                                          |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lr_data    nkss_taskset_dml.RecData;
  --------------------------------------------------------------------------------
  procedure atworker(fr_data in out nocopy lr_data%type)
  is
    pragma  autonomous_transaction;
    lc__    constant varchar2(100) := 'Nested Procedure ATWORKER:';
  begin
    nkss_taskset_dml.lock_row(fr_data => fr_data);
    commit;
  exception when others then
    raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
  end atworker;
  --------------------------------------------------------------------------------
begin
  dbms_output.enable(buffer_size => 1e6);
  select --+ choose
         a.rowid,
         a.id
    into lr_data.r#wid,
         lr_data.id
    from nkss_taskset    a
   where 1e1 = 1e1
     and rownum = 1;
  nkss_taskset_dml.select_row(fr_data => lr_data,
                              fv_lock => true);
  atworker(fr_data => lr_data);
  commit;
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_taskset_dml.select_row(fv_lock => true)   * main transaction                                |
prompt | nkss_taskset_dml.update_row()                  * autonomous transaction                          |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: ORA-20888 rowid[%s] locked by another session                                         |
prompt | * after about 4 seconds                                                                          |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lr_data    nkss_taskset_dml.RecData;
  --------------------------------------------------------------------------------
  procedure atworker(fr_data  in out nocopy lr_data%type)
  is
    pragma  autonomous_transaction;
    lc__    constant varchar2(100) := 'Nested Procedure ATWORKER:';
  begin
    fr_data.label := '::Modified by the autonomous transaction::';
    nkss_taskset_dml.update_row(fr_data => fr_data);
    commit;
  exception when others then
    raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
  end atworker;
  --------------------------------------------------------------------------------
begin
  dbms_output.enable(buffer_size => 1e6);
  select --+ choose
         a.rowid,
         a.id
    into lr_data.r#wid,
         lr_data.id
    from nkss_taskset    a
   where 1e1 = 1e1
     and rownum = 1;
  nkss_taskset_dml.select_row(fr_data => lr_data,
                              fv_lock => true);
  atworker(fr_data => lr_data);
  commit;
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_taskset_dml.select_row(fv_lock => true)   * main transaction                                |
prompt | nkss_taskset_dml.delete_row()                  * autonomous transaction                          |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: ORA-20888 rowid[%s] locked by another session                                         |
prompt | * after about 4 seconds                                                                          |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lr_data    nkss_taskset_dml.RecData;
  --------------------------------------------------------------------------------
  procedure atworker(fr_data  in out nocopy lr_data%type)
  is
    pragma  autonomous_transaction;
    lc__    constant varchar2(100) := 'Nested Procedure ATWORKER:';
  begin
    nkss_taskset_dml.delete_row(fr_data => fr_data);
    commit;
  exception when others then
    raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
  end atworker;
  --------------------------------------------------------------------------------
begin
  dbms_output.enable(buffer_size => 1e6);
  select --+ choose
         a.rowid,
         a.id
    into lr_data.r#wid,
         lr_data.id
    from nkss_taskset    a
   where 1e1 = 1e1
     and rownum = 1;
  nkss_taskset_dml.select_row(fr_data => lr_data,
                              fv_lock => true);
  atworker(fr_data => lr_data);
  commit;
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_taskset_dml.select_row(fv_lock => false)  * main transaction                                |
prompt | nkss_taskset_dml.update_row()                  * autonomous transaction                          |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: PL/SQL procedure successfully completed                                               |
prompt | * in out nocopy in an autonomous transaction                                                     |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lr_data    nkss_taskset_dml.RecData;
  --------------------------------------------------------------------------------
  procedure atworker(fr_data  in out nocopy lr_data%type)
  is
    pragma  autonomous_transaction;
    lc__    constant varchar2(100) := 'Nested Procedure ATWORKER:';
  begin
    fr_data.label := '::Modified by the autonomous transaction::';
    nkss_taskset_dml.update_row(fr_data => fr_data);
    commit;
  exception when others then
    raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
  end atworker;
  --------------------------------------------------------------------------------
begin
  dbms_output.enable(buffer_size => 1e6);
  select --+ choose
         a.rowid,
         a.id
    into lr_data.r#wid,
         lr_data.id
    from nkss_taskset    a
   where 1e1 = 1e1
     and rownum = 1;
  nkss_taskset_dml.select_row(fr_data => lr_data,
                              fv_lock => false);
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| Data before nkss_taskset_dml.update_row() call in an autonomous transaction                      |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('lr_data.id              = ' || to_char(lr_data.id));
  dbms_output.put_line('lr_data.created         = ' || to_char(lr_data.created, 'yyyy-mm-dd hh24:mi:ss.ff'));
  dbms_output.put_line('lr_data.label           = ' || lr_data.label);
  dbms_output.put_line('lr_data.payload(length) = ' || dbms_lob.getlength(lob_loc => lr_data.payload));
  dbms_output.put_line('lr_data.errorstack      = ' || lr_data.errorstack);
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| nkss_taskset_dml.update_row() call in an autonomous transaction                                  |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  atworker(fr_data => lr_data);
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| Data after nkss_taskset_dml.update_row() call in an autonomous transaction                       |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('lr_data.id              = ' || to_char(lr_data.id));
  dbms_output.put_line('lr_data.created         = ' || to_char(lr_data.created, 'yyyy-mm-dd hh24:mi:ss.ff'));
  dbms_output.put_line('lr_data.label           = ' || lr_data.label);
  dbms_output.put_line('lr_data.payload(length) = ' || dbms_lob.getlength(lob_loc => lr_data.payload));
  dbms_output.put_line('lr_data.errorstack      = ' || lr_data.errorstack);
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  commit;
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_taskset_dml.delete_row()  * main transaction                                                |
prompt | nkss_taskset_dml.delete_row()  * autonomous transaction                                          |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: ORA-20888 rowid[%s] locked by another session                                         |
prompt | * after about 4 seconds                                                                          |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lr_data    nkss_taskset_dml.RecData;
  --------------------------------------------------------------------------------
  procedure atworker(fr_data  in out nocopy lr_data%type)
  is
    pragma  autonomous_transaction;
    lc__    constant varchar2(100) := 'Nested Procedure ATWORKER:';
  begin
    nkss_taskset_dml.delete_row(fr_data => fr_data);
    commit;
  exception when others then
    raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
  end atworker;
  --------------------------------------------------------------------------------
begin
  dbms_output.enable(buffer_size => 1e6);
  select --+ choose
         a.rowid,
         a.id
    into lr_data.r#wid,
         lr_data.id
    from nkss_taskset    a
   where 1e1 = 1e1
     and rownum = 1;
  nkss_taskset_dml.delete_row(fr_data => lr_data);
  atworker(fr_data => lr_data);
  rollback;                                              -- revert to test nkss_taskset_dml.gc_limit
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_taskset_dml.delete_row()                                                                    |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: PL/SQL procedure successfully completed                                               |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lr_data    nkss_taskset_dml.RecData;
begin
  dbms_output.enable(buffer_size => 1e6);
  select --+ choose
         a.rowid,
         a.id
    into lr_data.r#wid,
         lr_data.id
    from nkss_taskset    a
   where 1e1 = 1e1
     and rownum = 1;
  nkss_taskset_dml.delete_row(fr_data => lr_data);
  rollback;                                              -- revert to test nkss_taskset_dml.gc_limit
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_taskset_dml.insert_all(fv_rebind => true)                                                   |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: ORA-20888 ft_data.count() is limited to %s elements                                   |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lc_limit   constant pls_integer := nkss_taskset_dml.gc_limit + 1;
  lt_data    nkss_taskset_dml.ArrData;
  i          pls_integer;
begin
  dbms_output.enable(buffer_size => 1e6);
  for i in 1 .. lc_limit loop
    -- Not mandatory will be replaced by sequence value on insert
    lt_data(i).id := -51;                                                                              --001 number(16)
    -- Not mandatory will be replaced by systimestamp on insert/update
    lt_data(i).created := to_timestamp('2008-04-23 11:59:37.145265665', 'yyyy-mm-dd hh24:mi:ss.ff');   --002 timestamp
    -- Mandatory
    lt_data(i).label := 'Initial Label';                                                               --003 varchar2(150 byte)
  end loop;
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data before nkss_taskset_dml.insert_all() call                                                   |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|      ID|CREATED                       |LABEL                                                     |');
    dbms_output.put_line('|--------|------------------------------|----------------------------------------------------------|');
    while (i is not null) loop
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 8));
      dbms_output.put('|' || rpad(to_char(lt_data(i).created, 'yyyy-mm-dd hh24:mi:ss.ff'), 30));
      dbms_output.put('|' || rpad(lt_data(i).label, 58));
      dbms_output.put_line('|');
      i := lt_data.next(i);
    end loop;
  end if;
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| nkss_taskset_dml.insert_all(fv_rebind => true) call                                              |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  nkss_taskset_dml.insert_all(ft_data   => lt_data,
                              fv_rebind => true);
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data after nkss_taskset_dml.insert_all() call                                                    |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|      ID|CREATED                       |LABEL                                                     |');
    dbms_output.put_line('|--------|------------------------------|----------------------------------------------------------|');
    while (i is not null) loop
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 8));
      dbms_output.put('|' || rpad(to_char(lt_data(i).created, 'yyyy-mm-dd hh24:mi:ss.ff'), 30));
      dbms_output.put('|' || rpad(lt_data(i).label, 58));
      dbms_output.put_line('|');
      i := lt_data.next(i);
    end loop;
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  end if;
  commit;
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_taskset_dml.insert_all(fv_rebind => true)                                                   |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: PL/SQL procedure successfully completed                                               |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lc_limit   constant pls_integer := nkss_taskset_dml.gc_limit;
  lt_data    nkss_taskset_dml.ArrData;
  i          pls_integer;
begin
  dbms_output.enable(buffer_size => 1e6);
  for i in 1 .. lc_limit loop
    -- Not mandatory will be replaced by sequence value on insert
    lt_data(i).id := -51;                                                                              --001 number(16)
    -- Not mandatory will be replaced by systimestamp on insert/update
    lt_data(i).created := to_timestamp('2008-04-23 11:59:37.145265665', 'yyyy-mm-dd hh24:mi:ss.ff');   --002 timestamp
    -- Mandatory
    lt_data(i).label := 'Initial Label';                                                               --003 varchar2(150 byte)
  end loop;
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data before nkss_taskset_dml.insert_all() call                                                   |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|      ID|CREATED                       |LABEL                                                     |');
    dbms_output.put_line('|--------|------------------------------|----------------------------------------------------------|');
    while (i is not null) loop
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 8));
      dbms_output.put('|' || rpad(to_char(lt_data(i).created, 'yyyy-mm-dd hh24:mi:ss.ff'), 30));
      dbms_output.put('|' || rpad(lt_data(i).label, 58));
      dbms_output.put_line('|');
      i := lt_data.next(i);
    end loop;
  end if;
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| nkss_taskset_dml.insert_all(fv_rebind => true) call                                              |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  nkss_taskset_dml.insert_all(ft_data   => lt_data,
                              fv_rebind => true);
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data after nkss_taskset_dml.insert_all() call                                                    |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|      ID|CREATED                       |LABEL                                                     |');
    dbms_output.put_line('|--------|------------------------------|----------------------------------------------------------|');
    while (i is not null) loop
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 8));
      dbms_output.put('|' || rpad(to_char(lt_data(i).created, 'yyyy-mm-dd hh24:mi:ss.ff'), 30));
      dbms_output.put('|' || rpad(lt_data(i).label, 58));
      dbms_output.put_line('|');
      i := lt_data.next(i);
    end loop;
  end if;
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  commit;
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_taskset_dml.update_all(fv_rebind => true)                                                   |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: ORA-20888 ft_data.count() is limited to %s elements                                   |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lc_limit   constant pls_integer := nkss_taskset_dml.gc_limit + 1;
  type weak_refcur is ref cursor;
  lv_refcur  weak_refcur;
  lt_data    nkss_taskset_dml.ArrData;
  i          pls_integer;
begin
  dbms_output.enable(buffer_size => 1e6);
  open lv_refcur for
  select --+ choose
         a.rowid,                                            -- 1/6 urowid,
         a.id,                                               -- 2/6 number(16),             -- PK 1/1
         a.created,                                          -- 3/6 timestamp,
         a.label,                                            -- 4/6 varchar2(150 byte),
         a.payload,                                          -- 5/6 clob,
         a.errorstack                                        -- 6/6 varchar2(4000 byte));
    from nkss_taskset    a
   where 1e1 = 1e1
     and rownum <= lc_limit;
  fetch lv_refcur bulk collect into lt_data;
  close lv_refcur;
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data before nkss_taskset_dml.update_all() call                                                   |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|      ID|CREATED                       |LABEL                                                     |');
    dbms_output.put_line('|--------|------------------------------|----------------------------------------------------------|');
    while (i is not null) loop
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 8));
      dbms_output.put('|' || rpad(to_char(lt_data(i).created, 'yyyy-mm-dd hh24:mi:ss.ff'), 30));
      dbms_output.put('|' || rpad(lt_data(i).label, 58));
      dbms_output.put_line('|');
      lt_data(i).label := 'Now is "' || lt_data(i).r#wid || '"';
      i := lt_data.next(i);
    end loop;
  end if;
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| nkss_taskset_dml.update_all(fv_rebind => true) call                                              |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  nkss_taskset_dml.update_all(ft_data   => lt_data,
                              fv_rebind => true);
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data after nkss_taskset_dml.update_all() call                                                    |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|      ID|CREATED                       |LABEL                                                     |');
    dbms_output.put_line('|--------|------------------------------|----------------------------------------------------------|');
    while (i is not null) loop
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 8));
      dbms_output.put('|' || rpad(to_char(lt_data(i).created, 'yyyy-mm-dd hh24:mi:ss.ff'), 30));
      dbms_output.put('|' || rpad(lt_data(i).label, 58));
      dbms_output.put_line('|');
      i := lt_data.next(i);
    end loop;
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  end if;
  commit;
exception when others then
  if (lv_refcur%isopen) then
    close lv_refcur;
  end if;
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_taskset_dml.update_all(fv_rebind => true)                                                   |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: PL/SQL procedure successfully completed                                               |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lc_limit   constant pls_integer := nkss_taskset_dml.gc_limit;
  type weak_refcur is ref cursor;
  lv_refcur  weak_refcur;
  lt_data    nkss_taskset_dml.ArrData;
  i          pls_integer;
begin
  dbms_output.enable(buffer_size => 1e6);
  dbms_output.enable(buffer_size => 1e6);
  open lv_refcur for
  select --+ choose
         a.rowid,                                            -- 1/6 urowid,
         a.id,                                               -- 2/6 number(16),             -- PK 1/1
         a.created,                                          -- 3/6 timestamp,
         a.label,                                            -- 4/6 varchar2(150 byte),
         a.payload,                                          -- 5/6 clob,
         a.errorstack                                        -- 6/6 varchar2(4000 byte));
    from nkss_taskset    a
   where 1e1 = 1e1
     and rownum <= lc_limit;
  fetch lv_refcur bulk collect into lt_data;
  close lv_refcur;
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data before nkss_taskset_dml.update_all() call                                                   |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|      ID|CREATED                       |LABEL                                                     |');
    dbms_output.put_line('|--------|------------------------------|----------------------------------------------------------|');
    while (i is not null) loop
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 8));
      dbms_output.put('|' || rpad(to_char(lt_data(i).created, 'yyyy-mm-dd hh24:mi:ss.ff'), 30));
      dbms_output.put('|' || rpad(lt_data(i).label, 58));
      dbms_output.put_line('|');
      lt_data(i).label := 'Now is "' || lt_data(i).r#wid || '"';
      i := lt_data.next(i);
    end loop;
  end if;
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| nkss_taskset_dml.update_all(fv_rebind => true) call                                              |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  nkss_taskset_dml.update_all(ft_data   => lt_data,
                              fv_rebind => true);
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data after nkss_taskset_dml.update_all() call                                                    |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|      ID|CREATED                       |LABEL                                                     |');
    dbms_output.put_line('|--------|------------------------------|----------------------------------------------------------|');
    while (i is not null) loop
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 8));
      dbms_output.put('|' || rpad(to_char(lt_data(i).created, 'yyyy-mm-dd hh24:mi:ss.ff'), 30));
      dbms_output.put('|' || rpad(lt_data(i).label, 58));
      dbms_output.put_line('|');
      i := lt_data.next(i);
    end loop;
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  end if;
  commit;
exception when others then
  if (lv_refcur%isopen) then
    close lv_refcur;
  end if;
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | EOS: End of script                                                                               |
prompt +--------------------------------------------------------------------------------------------------+
spool off
set feedback on
set heading on
set echo off
