------------------------------------------------------------------------------------------------------------------------
-- NKSS: PL/SQL Simple Scheduler
-- * This script tests DML API(CRUD) for table NKSS_TASKLIST(Generated by NKSG Simple Generator);
-- * Some additional code were added/modified/removed after generation, as SEQUENCE, SYSTIMESTAMP, etc;
------------------------------------------------------------------------------------------------------------------------
-- @dmlapi-tasklist.sql
------------------------------------------------------------------------------------------------------------------------
set echo off
spool dmlapi-tasklist.log
prompt +-------------------------------------------------------------------------+
prompt | NKSS: PL/SQL Simple Scheduler                                           |
prompt |-------------------------------------------------------------------------|
prompt | (c) Copyright 2017 Geraldo Viana (r4vrya@gmail.com)                     |
prompt |                                                                         |
prompt | Licensed under the Apache License, Version 2.0 (the "License"):         |
prompt | you may not use this file except in compliance with the License.        |
prompt | You may obtain a copy of the License at                                 |
prompt |                                                                         |
prompt |     http://www.apache.org/licenses/LICENSE-2.0                          |
prompt |                                                                         |
prompt | Unless required by applicable law or agreed to in writing, software     |
prompt | distributed under the License is distributed on an "AS IS" BASIS,       |
prompt | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.|
prompt | See the License for the specific language governing permissions and     |
prompt | limitations under the License.                                          |
prompt |-------------------------------------------------------------------------|
prompt | SQL> @dmlapi-tasklist.sql                                               |
prompt +-------------------------------------------------------------------------+
whenever sqlerror continue
whenever oserror  continue
set define off
set feedback on
set heading off
set linesize 120
set loboffset 1
set long 16777216
set longchunksize 8192
set pause off
set scan on
set serveroutput on size 1000000
set sqlblanklines on
set tab off
set termout on
set timing on
set trimspool on
set verify off
set wrap on

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_tasklist_dml.insert_row()                                                                   |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: PL/SQL procedure successfully completed                                               |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lr_data    nkss_tasklist_dml.RecData;
  lv_setid   integer;
begin
  dbms_output.enable(buffer_size => 1e6);
  -- Find a parent set for our task
  select --+ choose
         a.id
    into lv_setid
    from nkss_taskset    a
   where 1e1 = 1e1
     and rownum = 1;
  -- Not mandatory will be replaced by sequence value on insert
  lr_data.id := -29;                                                                              --001 number(16)
  -- Mandatory: Task Set ID
  lr_data.pid := lv_setid;                                                                        --002 number(16)
  -- Not mandatory will be replaced by -1 on insert
  lr_data.status := 8;                                                                            --003 number(1)
  -- Mandatory
  lr_data.payload := 'begin null; end;';                                                          --004 clob
  -- Cannot be assigned on insert, will be nulled
  lr_data.started := to_timestamp('2008-04-23 11:59:37.145265665', 'yyyy-mm-dd hh24:mi:ss.ff');   --005 timestamp
  -- Cannot be assigned on insert, will be nulled
  lr_data.finished := to_timestamp('2008-04-23 11:59:37.145265665', 'yyyy-mm-dd hh24:mi:ss.ff');  --006 timestamp
  -- Cannot be assigned on insert, will be nulled
  lr_data.cputime := 4473;                                                                        --007 number(16)
  -- Cannot be assigned on insert, will be nulled
  lr_data.errorstack := 'The API will wipe me off';                                               --008 varchar2(4000 byte)
  -- Cannot be assigned on insert, will be nulled
  lr_data.callstack := 'The API will wipe me off';                                                --009 varchar2(4000 byte)
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| Data before nkss_tasklist_dml.insert_row() call                                                  |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('lr_data.id              = ' || to_char(lr_data.id));
  dbms_output.put_line('lr_data.pid             = ' || to_char(lr_data.pid));
  dbms_output.put_line('lr_data.status          = ' || to_char(lr_data.status));
  dbms_output.put_line('lr_data.payload(length) = ' || dbms_lob.getlength(lob_loc => lr_data.payload));
  dbms_output.put_line('lr_data.started         = ' || to_char(lr_data.started, 'yyyy-mm-dd hh24:mi:ss.ff'));
  dbms_output.put_line('lr_data.finished        = ' || to_char(lr_data.finished, 'yyyy-mm-dd hh24:mi:ss.ff'));
  dbms_output.put_line('lr_data.errorstack      = ' || lr_data.errorstack);
  dbms_output.put_line('lr_data.callstack       = ' || lr_data.errorstack);
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| nkss_tasklist_dml.insert_row() call                                                              |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  nkss_tasklist_dml.insert_row(fr_data => lr_data);
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| Data after nkss_tasklist_dml.insert_row() call                                                   |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('lr_data.id              = ' || to_char(lr_data.id));
  dbms_output.put_line('lr_data.pid             = ' || to_char(lr_data.pid));
  dbms_output.put_line('lr_data.status          = ' || to_char(lr_data.status));
  dbms_output.put_line('lr_data.payload(length) = ' || dbms_lob.getlength(lob_loc => lr_data.payload));
  dbms_output.put_line('lr_data.started         = ' || to_char(lr_data.started, 'yyyy-mm-dd hh24:mi:ss.ff'));
  dbms_output.put_line('lr_data.finished        = ' || to_char(lr_data.finished, 'yyyy-mm-dd hh24:mi:ss.ff'));
  dbms_output.put_line('lr_data.errorstack      = ' || lr_data.errorstack);
  dbms_output.put_line('lr_data.callstack       = ' || lr_data.errorstack);
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  commit;
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_tasklist_dml.select_row(fv_lock => true)   * main transaction                               |
prompt | nkss_tasklist_dml.lock_row()                    * autonomous transaction                         |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: ORA-20888 rowid[%s] locked by another session                                         |
prompt | * after about 4 seconds                                                                          |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lr_data    nkss_tasklist_dml.RecData;
  --------------------------------------------------------------------------------
  procedure atworker(fr_data in out nocopy lr_data%type)
  is
    pragma  autonomous_transaction;
    lc__    constant varchar2(100) := 'Nested Procedure ATWORKER:';
  begin
    nkss_tasklist_dml.lock_row(fr_data => fr_data);
    commit;
  exception when others then
    raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
  end atworker;
  --------------------------------------------------------------------------------
begin
  dbms_output.enable(buffer_size => 1e6);
  select --+ choose
         a.rowid,
         a.id
    into lr_data.r#wid,
         lr_data.id
    from nkss_tasklist    a
   where 1e1 = 1e1
     and rownum = 1;
  nkss_tasklist_dml.select_row(fr_data => lr_data,
                               fv_lock => true);
  atworker(fr_data => lr_data);
  commit;
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_tasklist_dml.select_row(fv_lock => true)   * main transaction                               |
prompt | nkss_tasklist_dml.update_row()                  * autonomous transaction                         |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: ORA-20888 rowid[%s] locked by another session                                         |
prompt | * after about 4 seconds                                                                          |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lr_data    nkss_tasklist_dml.RecData;
  --------------------------------------------------------------------------------
  procedure atworker(fr_data  in out nocopy lr_data%type)
  is
    pragma  autonomous_transaction;
    lc__    constant varchar2(100) := 'Nested Procedure ATWORKER:';
  begin
    fr_data.status := 0;
    nkss_tasklist_dml.update_row(fr_data => fr_data);
    commit;
  exception when others then
    raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
  end atworker;
  --------------------------------------------------------------------------------
begin
  dbms_output.enable(buffer_size => 1e6);
  select --+ choose
         a.rowid,
         a.id
    into lr_data.r#wid,
         lr_data.id
    from nkss_tasklist    a
   where 1e1 = 1e1
     and rownum = 1;
  nkss_tasklist_dml.select_row(fr_data => lr_data,
                               fv_lock => true);
  atworker(fr_data => lr_data);
  commit;
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_tasklist_dml.select_row(fv_lock => true)   * main transaction                               |
prompt | nkss_tasklist_dml.delete_row()                  * autonomous transaction                         |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: ORA-20888 rowid[%s] locked by another session                                         |
prompt | * after about 4 seconds                                                                          |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lr_data    nkss_tasklist_dml.RecData;
  --------------------------------------------------------------------------------
  procedure atworker(fr_data  in out nocopy lr_data%type)
  is
    pragma  autonomous_transaction;
    lc__    constant varchar2(100) := 'Nested Procedure ATWORKER:';
  begin
    nkss_tasklist_dml.delete_row(fr_data => fr_data);
    commit;
  exception when others then
    raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
  end atworker;
  --------------------------------------------------------------------------------
begin
  dbms_output.enable(buffer_size => 1e6);
  select --+ choose
         a.rowid,
         a.id
    into lr_data.r#wid,
         lr_data.id
    from nkss_tasklist    a
   where 1e1 = 1e1
     and rownum = 1;
  nkss_tasklist_dml.select_row(fr_data => lr_data,
                               fv_lock => true);
  atworker(fr_data => lr_data);
  commit;
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_tasklist_dml.select_row(fv_lock => false)  * main transaction                               |
prompt | nkss_tasklist_dml.update_row()                  * autonomous transaction                         |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: PL/SQL procedure successfully completed                                               |
prompt | * in out nocopy in an autonomous transaction                                                     |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lr_data    nkss_tasklist_dml.RecData;
  --------------------------------------------------------------------------------
  procedure atworker(fr_data  in out nocopy lr_data%type)
  is
    pragma  autonomous_transaction;
    lc__    constant varchar2(100) := 'Nested Procedure ATWORKER:';
  begin
    fr_data.status := 0;
    nkss_tasklist_dml.update_row(fr_data => fr_data);
    commit;
  exception when others then
    raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
  end atworker;
  --------------------------------------------------------------------------------
begin
  dbms_output.enable(buffer_size => 1e6);
  select --+ choose
         a.rowid,
         a.id
    into lr_data.r#wid,
         lr_data.id
    from nkss_tasklist    a
   where 1e1 = 1e1
     and rownum = 1;
  nkss_tasklist_dml.select_row(fr_data => lr_data,
                               fv_lock => false);
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| Data before nkss_tasklist_dml.update_row() call in an autonomous transaction                     |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('lr_data.id              = ' || to_char(lr_data.id));
  dbms_output.put_line('lr_data.pid             = ' || to_char(lr_data.pid));
  dbms_output.put_line('lr_data.status          = ' || to_char(lr_data.status));
  dbms_output.put_line('lr_data.payload(length) = ' || dbms_lob.getlength(lob_loc => lr_data.payload));
  dbms_output.put_line('lr_data.started         = ' || to_char(lr_data.started, 'yyyy-mm-dd hh24:mi:ss.ff'));
  dbms_output.put_line('lr_data.finished        = ' || to_char(lr_data.finished, 'yyyy-mm-dd hh24:mi:ss.ff'));
  dbms_output.put_line('lr_data.errorstack      = ' || lr_data.errorstack);
  dbms_output.put_line('lr_data.callstack       = ' || lr_data.errorstack);
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| nkss_tasklist_dml.update_row() call in an autonomous transaction                                 |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  atworker(fr_data => lr_data);
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| Data after nkss_tasklist_dml.update_row() call in an autonomous transaction                      |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('lr_data.id              = ' || to_char(lr_data.id));
  dbms_output.put_line('lr_data.pid             = ' || to_char(lr_data.pid));
  dbms_output.put_line('lr_data.status          = ' || to_char(lr_data.status));
  dbms_output.put_line('lr_data.payload(length) = ' || dbms_lob.getlength(lob_loc => lr_data.payload));
  dbms_output.put_line('lr_data.started         = ' || to_char(lr_data.started, 'yyyy-mm-dd hh24:mi:ss.ff'));
  dbms_output.put_line('lr_data.finished        = ' || to_char(lr_data.finished, 'yyyy-mm-dd hh24:mi:ss.ff'));
  dbms_output.put_line('lr_data.errorstack      = ' || lr_data.errorstack);
  dbms_output.put_line('lr_data.callstack       = ' || lr_data.errorstack);
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  commit;
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_tasklist_dml.delete_row()  * main transaction                                               |
prompt | nkss_tasklist_dml.delete_row()  * autonomous transaction                                         |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: ORA-20888 rowid[%s] locked by another session                                         |
prompt | * after about 4 seconds                                                                          |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lr_data    nkss_tasklist_dml.RecData;
  --------------------------------------------------------------------------------
  procedure atworker(fr_data  in out nocopy lr_data%type)
  is
    pragma  autonomous_transaction;
    lc__    constant varchar2(100) := 'Nested Procedure ATWORKER:';
  begin
    nkss_tasklist_dml.delete_row(fr_data => fr_data);
    commit;
  exception when others then
    raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
  end atworker;
  --------------------------------------------------------------------------------
begin
  dbms_output.enable(buffer_size => 1e6);
  select --+ choose
         a.rowid,
         a.id
    into lr_data.r#wid,
         lr_data.id
    from nkss_tasklist    a
   where 1e1 = 1e1
     and rownum = 1;
  nkss_tasklist_dml.delete_row(fr_data => lr_data);
  atworker(fr_data => lr_data);
  rollback;                                              -- revert to test nkss_tasklist_dml.gc_limit
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_tasklist_dml.delete_row()                                                                   |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: PL/SQL procedure successfully completed                                               |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lr_data    nkss_tasklist_dml.RecData;
begin
  dbms_output.enable(buffer_size => 1e6);
  select --+ choose
         a.rowid,
         a.id
    into lr_data.r#wid,
         lr_data.id
    from nkss_tasklist    a
   where 1e1 = 1e1
     and rownum = 1;
  nkss_tasklist_dml.delete_row(fr_data => lr_data);
  rollback;                                              -- revert to test nkss_tasklist_dml.gc_limit
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_tasklist_dml.insert_all(fv_rebind => true)                                                  |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: ORA-20888 ft_data.count() is limited to %s elements                                   |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lc_limit   constant pls_integer := nkss_tasklist_dml.gc_limit + 1;
  lv_setid   integer;
  lt_data    nkss_tasklist_dml.ArrData;
  i          pls_integer;
begin
  dbms_output.enable(buffer_size => 1e6);
  -- Find a parent set for our task
  select --+ choose
         a.id
    into lv_setid
    from nkss_taskset    a
   where 1e1 = 1e1
     and rownum = 1;
  for i in 1 .. lc_limit loop
    -- Not mandatory will be replaced by sequence value on insert
    lt_data(i).id := -29;                                                                           --001 number(16)
    -- Mandatory: Task Set ID
    lt_data(i).pid := lv_setid;                                                                     --002 number(16)
    -- Not mandatory will be replaced by -1 on insert
    lt_data(i).status := 8;                                                                         --003 number(1)
    -- Mandatory
    lt_data(i).payload := 'begin null; end;';                                                       --004 clob
  end loop;
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data before nkss_tasklist_dml.insert_all() call                                                  |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|        ID|       PID| STATUS | PAYLOAD                                                           |');
    dbms_output.put_line('|----------|----------|--------|-------------------------------------------------------------------|');
    while (i is not null) loop
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).pid), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).status), 8));
      dbms_output.put('|' || lpad(' ', 67));
      dbms_output.put_line('|');
      i := lt_data.next(i);
    end loop;
  end if;
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| nkss_tasklist_dml.insert_all(fv_rebind => true) call                                             |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  nkss_tasklist_dml.insert_all(ft_data   => lt_data,
                               fv_rebind => true);
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data after nkss_tasklist_dml.insert_all() call                                                   |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|        ID|       PID| STATUS | PAYLOAD                                                           |');
    dbms_output.put_line('|----------|----------|--------|-------------------------------------------------------------------|');
    while (i is not null) loop
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).pid), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).status), 8));
      dbms_output.put('|' || lpad(' ', 67));
      dbms_output.put_line('|');
      i := lt_data.next(i);
    end loop;
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  end if;
  commit;
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_tasklist_dml.insert_all(fv_rebind => true)                                                  |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: PL/SQL procedure successfully completed                                               |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lc_limit   constant pls_integer := nkss_tasklist_dml.gc_limit;
  lv_setid   integer;
  lt_data    nkss_tasklist_dml.ArrData;
  i          pls_integer;
begin
  dbms_output.enable(buffer_size => 1e6);
  -- Find a parent set for our task
  select --+ choose
         a.id
    into lv_setid
    from nkss_taskset    a
   where 1e1 = 1e1
     and rownum = 1;
  for i in 1 .. lc_limit loop
    -- Not mandatory will be replaced by sequence value on insert
    lt_data(i).id := -29;                                                                           --001 number(16)
    -- Mandatory: Task Set ID
    lt_data(i).pid := lv_setid;                                                                     --002 number(16)
    -- Not mandatory will be replaced by -1 on insert
    lt_data(i).status := 8;                                                                         --003 number(1)
    -- Mandatory
    lt_data(i).payload := 'begin null; end;';                                                       --004 clob
  end loop;
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data before nkss_tasklist_dml.insert_all() call                                                  |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|        ID|       PID| STATUS | PAYLOAD                                                           |');
    dbms_output.put_line('|----------|----------|--------|-------------------------------------------------------------------|');
    while (i is not null) loop
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).pid), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).status), 8));
      dbms_output.put('|' || lpad(' ', 67));
      dbms_output.put_line('|');
      i := lt_data.next(i);
    end loop;
  end if;
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| nkss_tasklist_dml.insert_all(fv_rebind => true) call                                             |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  nkss_tasklist_dml.insert_all(ft_data   => lt_data,
                               fv_rebind => true);
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data after nkss_tasklist_dml.insert_all() call                                                   |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|        ID|       PID| STATUS | PAYLOAD                                                           |');
    dbms_output.put_line('|----------|----------|--------|-------------------------------------------------------------------|');
    while (i is not null) loop
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).pid), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).status), 8));
      dbms_output.put('|' || lpad(' ', 67));
      dbms_output.put_line('|');
      i := lt_data.next(i);
    end loop;
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  end if;
  commit;
exception when others then
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_tasklist_dml.update_all(fv_rebind => true)                                                  |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: ORA-20888 ft_data.count() is limited to %s elements                                   |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lc_limit   constant pls_integer := nkss_tasklist_dml.gc_limit + 1;
  type weak_refcur is ref cursor;
  lv_refcur  weak_refcur;
  lt_data    nkss_tasklist_dml.ArrData;
  i          pls_integer;
begin
  dbms_output.enable(buffer_size => 1e6);
  open lv_refcur for
  select --+ choose
         a.rowid,                                            --000 urowid
         a.id,                                               --001 number(16)               -- PK 1/1
         a.pid,                                              --002 number(16)
         a.status,                                           --003 number(1)
         a.payload,                                          --004 clob
         a.started,                                          --005 timestamp
         a.finished,                                         --006 timestamp
         a.cputime,                                          --007 number(16)
         a.errorstack,                                       --008 varchar2(4000 byte)
         a.callstack                                         --009 varchar2(4000 byte)
    from nkss_tasklist    a
   where 1e1 = 1e1
     and rownum <= lc_limit;
  fetch lv_refcur bulk collect into lt_data;
  close lv_refcur;
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data before nkss_tasklist_dml.update_all() call                                                  |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|        ID|       PID| STATUS | PAYLOAD                                                           |');
    dbms_output.put_line('|----------|----------|--------|-------------------------------------------------------------------|');
    while (i is not null) loop
      lt_data(i).status := 1;
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).pid), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).status), 8));
      dbms_output.put('|' || lpad(' ', 67));
      dbms_output.put_line('|');
      i := lt_data.next(i);
    end loop;
  end if;
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| nkss_tasklist_dml.update_all(fv_rebind => true) call                                             |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  nkss_tasklist_dml.update_all(ft_data   => lt_data,
                              fv_rebind => true);
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data after nkss_tasklist_dml.update_all() call                                                   |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|        ID|       PID| STATUS | PAYLOAD                                                           |');
    dbms_output.put_line('|----------|----------|--------|-------------------------------------------------------------------|');
    while (i is not null) loop
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).pid), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).status), 8));
      dbms_output.put('|' || lpad(' ', 67));
      dbms_output.put_line('|');
      i := lt_data.next(i);
    end loop;
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  end if;
  commit;
exception when others then
  if (lv_refcur%isopen) then
    close lv_refcur;
  end if;
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | nkss_tasklist_dml.update_all(fv_rebind => true)                                                  |
prompt |--------------------------------------------------------------------------------------------------|
prompt | Expecting: PL/SQL procedure successfully completed                                               |
prompt +--------------------------------------------------------------------------------------------------+
declare
  lc__       constant varchar2(100) := 'Anonymous PL/SQL Block:';
  nl         constant varchar2(3) := '
';
  lc_limit   constant pls_integer := nkss_tasklist_dml.gc_limit;
  type weak_refcur is ref cursor;
  lv_refcur  weak_refcur;
  lt_data    nkss_tasklist_dml.ArrData;
  i          pls_integer;
begin
  dbms_output.enable(buffer_size => 1e6);
  open lv_refcur for
  select --+ choose
         a.rowid,                                            --000 urowid
         a.id,                                               --001 number(16)               -- PK 1/1
         a.pid,                                              --002 number(16)
         a.status,                                           --003 number(1)
         a.payload,                                          --004 clob
         a.started,                                          --005 timestamp
         a.finished,                                         --006 timestamp
         a.cputime,                                          --007 number(16)
         a.errorstack,                                       --008 varchar2(4000 byte)
         a.callstack                                         --009 varchar2(4000 byte)
    from nkss_tasklist    a
   where 1e1 = 1e1
     and rownum <= lc_limit;
  fetch lv_refcur bulk collect into lt_data;
  close lv_refcur;
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data before nkss_tasklist_dml.update_all() call                                                  |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|        ID|       PID| STATUS | PAYLOAD                                                           |');
    dbms_output.put_line('|----------|----------|--------|-------------------------------------------------------------------|');
    while (i is not null) loop
      lt_data(i).status := 1;
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).pid), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).status), 8));
      dbms_output.put('|' || lpad(' ', 67));
      dbms_output.put_line('|');
      i := lt_data.next(i);
    end loop;
  end if;
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  dbms_output.put_line('| nkss_tasklist_dml.update_all(fv_rebind => true) call                                             |');
  dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  nkss_tasklist_dml.update_all(ft_data   => lt_data,
                              fv_rebind => true);
  i := lt_data.first;
  if (i is not null) then
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
    dbms_output.put_line('| Data after nkss_tasklist_dml.update_all() call                                                   |');
    dbms_output.put_line('|--------------------------------------------------------------------------------------------------|');
    dbms_output.put_line('|        ID|       PID| STATUS | PAYLOAD                                                           |');
    dbms_output.put_line('|----------|----------|--------|-------------------------------------------------------------------|');
    while (i is not null) loop
      dbms_output.put('|' || lpad(to_char(lt_data(i).id), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).pid), 10));
      dbms_output.put('|' || lpad(to_char(lt_data(i).status), 8));
      dbms_output.put('|' || lpad(' ', 67));
      dbms_output.put_line('|');
      i := lt_data.next(i);
    end loop;
    dbms_output.put_line('+--------------------------------------------------------------------------------------------------+');
  end if;
  commit;
exception when others then
  if (lv_refcur%isopen) then
    close lv_refcur;
  end if;
  raise_application_error(-20777, lc__ || $$plsql_line || nl || dbms_utility.format_error_stack);
end main;
/

prompt +--------------------------------------------------------------------------------------------------+
prompt | EOS: End of script                                                                               |
prompt +--------------------------------------------------------------------------------------------------+
spool off
set feedback on
set heading on
set echo off
